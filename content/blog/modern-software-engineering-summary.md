---
title: Modern Software Engineering: Ch. 4–8 Summary
date: 2025-03-28
tags: ["software engineering"]
ShowToc: false
showTopProgressBar: true
---

I recently finished reading *Modern Software Engineering* by Dave Farley and would like to share summaries of the four chapters I found most useful, especially for new software engineers. In my opinion, reading these summaries can serve as a substitute for reading the full chapters. I generated each summary using ChatGPT and then refined them through several iterations to ensure they capture all the main ideas accurately.

## Chapter 4 (Working Iteratively)

- Iteration is a procedure that drives learning. Iteration allows us to learn, react, and adapt to what we have learned. Without iteration, and the closely related activity of collecting feedback, there is no opportunity to learn on an ongoing basis. Fundamentally, iteration allows us to make mistakes and to correct them, or make advances and enhance them.
- Iteration allows us to progressively approach some goal. Its real power is that it allows us to do this even when we don't really know how to approach our goals. As long as we have some way of telling whether we are closer to or further from our goal. We could even iterate randomly and still achieve our goal. We can discard the steps that take us further away and prefer the steps that move us nearer. This is in essence how evolution works. It is also at the heart of how modern machine learning (ML) works.
- We can't afford to spend lots of time in analysis and design without creating anything, because that means more time not learning what really works. We need to do just enough analysis, design, coding, testing, and releasing to get our ideas out into the hands of our customers and users so that we can see what really works. We need to reflect on that and then, given that learning, adapt what we do next to take advantage of it.
- Industry data says that for the best software companies in the world, two-thirds of their ideas produce zero or negative value. We are terrible at guessing what our users want. Even when we ask our users, they don't know what they want either. The most effective approach is to iterate. It is accepting that some, maybe even many, of our ideas will be wrong and work in a way that allows us to try them out as quickly, cheaply, and efficiently as possible.
- To make progress we must take a chance, make a guess, be willing to take a risk. We are very bad at guessing, though, so we need to work more defensively by proceeding in small steps and limit the scope of our guesses.
- If we work iteratively in small steps, the cost of any single step going wrong is inevitably lower.
- An iterative approach allows us to always have the most up-to-date picture of the situation that we are really in, rather than some predictive, theoretical, always-inaccurate version of that situation. It allows us to learn, react, and adapt as changes happen along the way. **Working iteratively is the only effective strategy for a changing situation.**
- Practices like Continuous Integration and Continuous Delivery are inherently iterative, promoting frequent, small changes and continuous learning. This approach not only improves the quality of the code but also aligns development practices with the iterative mindset.

## Chapter 5 (Feedback)

- Without feedback, there is no opportunity to learn. We can only guess, rather than make decisions based on reality. Despite this, it is surprising how little attention many people and organizations pay to it.
- Software development is always an exercise in learning, and the environment in which it takes place is always changing; therefore, feedback is an essential aspect of any effective software development process.
- By following an approach like test-driven development, where tests are written and run before coding, fast, high-quality feedback can be achieved in milliseconds. This enables immediate validation of correctness, quickly catching mistakes and design issues.
- Continuous integration is about evaluating every change to the system along with every other change as frequently as possible, as close to "continuously" as we can practically get. Continuous integration, when practiced correctly, means that we get regular, frequent drips of feedback. It gives us powerful insight into the state of our code and the behavior of our system throughout the working day. For CI to work, we have to commit our changes frequently enough to gain that feedback. Not only does this approach mean that our software is always in a deployable state, but it also encourages us to design our work in a way that sustains this approach.
- A feedback-driven approach also shapes software architecture. Continuous delivery demands that software be constantly ready for release. This encourages architectures that are modular, testable, and easier to deploy.
- Feedback loops in product design validate the effectiveness of ideas by directly measuring customer usage and satisfaction. Continuous delivery supports this by allowing organizations to deploy and test ideas quickly, enabling faster learning about customer needs and product effectiveness.

## Chapter 6 (Incrementalism)

- If working iteratively is about refining and improving something over a series of iterations, then working incrementally is about building a system, and ideally releasing it, piece by piece.
- To create complex systems, we need both approaches. An incremental approach allows us to decompose work and to deliver value step-by-step (incrementally), getting to value sooner and delivering value in smaller, simpler steps.
- Working in ways that allow us the freedom to change our code and change our minds as our understanding deepens is fundamental to good engineering and is what incrementalism is built upon. Striving to be able to work incrementally then is also striving for higher-quality systems. If your code is hard to change, it is low quality, whatever it does.

## Chapter 7 (Empiricism)

- Empiricism focuses on decision-making based on evidence and real-world observations. In engineering, especially software engineering, empiricism ensures that solutions are grounded in practical reality rather than abstract theories.
- Software systems often surprise developers when deployed in production. These surprises should be seen as opportunities to learn. Production environments expose the reality of a system's behavior, making it clear that software is a "best guess" at functionality. The true test of a system's quality comes in real-world usage, where unexpected behaviors are inevitable.
- While both experimentation and empiricism rely on observation, they serve different purposes. Experimentation tests a specific hypothesis under controlled conditions, while empiricism involves observing outcomes from real-world environments without the strict structure of a controlled experiment. Empiricism can validate or challenge assumptions based on broader, more informal observations. It is not a replacement for structured experimentation but rather complements it by allowing developers to observe results in less controlled but more realistic settings.
- Empiricism is essential in debugging and problem-solving. Assumptions based on prior experience can lead to incorrect conclusions, and only by gathering real-world evidence and thoroughly testing can the true nature of an issue be uncovered. Empirical investigation, rather than reliance on intuition or preconceived theories, leads to more accurate understanding and resolution of complex problems in software systems. This highlights the need to challenge assumptions and base decisions on observable facts.
- Human beings are prone to cognitive biases and shortcuts, often making us jump to conclusions based on incomplete data. These biases helped humans survive in primitive environments but can lead to faulty decisions in complex engineering problems. To avoid self-deception, it is crucial to gather organized, structured feedback from reality and resist the temptation to shape facts to fit preconceived theories. Richard Feynman famously characterized science as follows: *The first principle is that you must not fool yourself – and you are the easiest person to fool.* Empiricism requires rigorous attention to facts and a willingness to challenge initial impressions.
- Developers may invent realities that suit their assumptions, particularly when working with complex systems. Theoretical models that seem correct in principle often fail when tested empirically.
- Empirical reality must guide decision-making, not assumptions or untested theories. Skepticism and evidence-based problem-solving should be central to development practices. Developers should assume their assumptions might be wrong and actively seek evidence to confirm or refute them.
- Engineering, unlike pure science, requires us to focus on the practicality of our solutions. This is where empiricism becomes crucial. It's not sufficient to simply observe the world, make assumptions based on those observations, and assume we are correct just because the data came from real-world sources. That approach leads to both bad science and poor engineering. Since engineering is a practical field, we must remain skeptical of our assumptions and continually test them through experiments, always verifying them against real-world experience.

## Chapter 8 (Being Experimental)

- Being experimental means moving away from decisions based on authority and instead basing decisions on empirical evidence. It encourages a shift in mindset where decisions in software development are made based on experiments and real-world evidence. For example, instead of debating whether Clojure is better than C#, small trials can test aspects like stability and performance to make informed choices.
- Feedback is central to being experimental in software development. Efficient, frequent feedback enables developers to quickly learn from the results of their work and adjust their approach. Whether the feedback comes from automated tests or user interactions, it must be gathered quickly and interpreted carefully to drive continuous improvement.
- Every experiment starts with a hypothesis—a proposed explanation or prediction that can be tested. In software engineering, hypotheses might be about the effectiveness of a certain architecture, the scalability of a system, or the speed of a specific code optimization. Hypotheses should be clear, specific, and measurable.
- Measurement is crucial for validating the predictions of hypotheses. However, poor measurements can mislead, as illustrated by a client case where incentivizing developers based on test coverage led to the creation of useless tests with no assertions. This example shows how focusing on the wrong metrics can skew results. The correct measurement in this case would have been software stability, not just the number of tests. A good experiment relies on accurate, meaningful metrics that reflect the true quality or effectiveness of the software.
- Controlling variables is necessary to gather reliable data from experiments. By controlling variables (like environment, input date, dependencies, hardware, etc.), you ensure that any changes in the outcome can be attributed to the variable you're testing — not something else. For example, if you're testing a new caching strategy, but the server load is fluctuating wildly, your results might be skewed. Controlling for load ensures the cache strategy is the real difference-maker.
- Automated tests are considered small-scale experiments that provide constant feedback on software quality. They can be seen as hypotheses about how the software should behave under certain conditions, and running these tests validates or invalidates the predictions.
- Different sciences, such as physics or biology, might have different degrees of precision, but they all benefit from systematic experimentation. This analogy is used to reinforce that while software experiments might not reach the precision of physics, they are still valuable for learning and improving. By organizing software development around experiments, teams can generate deeper insights into system behavior and make better decisions.
